


Question #1

The STUDENTS table exists in your schema.
Examine the DECLARE section of a PL/SQL block:

DECLARE
TYPE studentcur_t IS REF CURSOR RETURN cust%ROWTYPE;
TYPE teachercur_t IS REF CURSOR;

cursor1 studentcur_t;
cursor1 teachercur_t;
cursor3 SYS_REFCURSOR;

CURSOR stcur  IS SELECT * FROM students;

Which two blocks are valid?

A.	BEGIN 
OPEN cursor3 FOR SELECT * FROM students; 
cursor1 :=cursor3; 
END;

B.	BEGIN 
OPEN stcur; 
cursor1 :=stcur; 
END;

C.	BEGIN 
OPEN cursor1 FOR SELECT * FROM students; 
stcur :=cursor1;
END;

D.	BEGIN 
OPEN stcur; 
cursor3 :=stcur;
END;

E.	BEGIN 
OPEN cursor1 FOR SELECT * FROM students; 
cursor2 :=cursor1;
END;












Question #2
Examine the code:
 

CREATE PACKAGE pkg IS
    TYPE rec_typ IS RECORD (id INTEGER, first_name VARCHAR2(50));
    TYPE tab_typ IS TABLE OF rec_type INDEX BY PLS_INTERGER;
     x tab_typ;
END pkg;
/
CREATE FUNCTION f(x pkg.tab_typ) RETURN VARCHAR2 IS
     r VARCHAR2(100);
BEGIN
  FOR I IN 1..x.COUNT LOOP
  r:=r || '' || x(i).id || x(i).first_name;
  END LOOP;
  RETURN r;
END f;

Which two subprograms will be created successfully?

A.
CREATE FUNCTION p4 (y pkg.tab_typ) 
RETURN pkg.tab_typ IS 
BEGIN 
EXECUTE IMMEDIATE SELECT pdt_id, pdt_name
FROM TABLE (:b) BULK COLLECT INTO pkg.x USING y; 
RETURN pkg.x; 
END p4;

B. 
CREATE PROCEDURE p1 (y IN OUT pkg.tab_typ) IS 
BEGIN 
EXECUTE IMMEDIATE SELECT f (:b) FROM DUAL INTO y USING pkg.x; 
END p1;

C. 
CREATE PROCEDURE p2 (v IN OUT VARCHAR2) IS
BEGIN 
EXECUTE IMMEDIATE SELECT f (:b) FROM DUAL INTO v USING pkg.x;
END p2;

D. 
CREATE FUNCTION p3 RETURN pkg. tab_typ IS 
BEGIN 
EXECUTE IMMEDIATE SELECT f (:b) FROM DUAL INTO pkg.x; 
END p3;

E. 
CREATE PROCEDURE p5 (y pkg. rec_typ) IS 
BEGIN 
EXECUTE IMMEDIATE SELECT pdt_name 
FROM TABLE (:b) BULK COLLECT INTO y USING pkg.x;





Question #3
Examine the section of code taken from a PL/SQL program:
 
PLSQL_OPTIMIZE_LEVEL PARAMETER is set to 3.
Which two statements are true?
A.	Calls to TESTPROC will always be inlined as it is compiled with    
  PLSQL_OPTIMIZE_LEVEL=3.
B. Calls to TESTPROC are never inlined in both lines commented as Call1 and Call 2.
C. Calls to TESTPROC are not inlined in the line commented as Call 1.
D. Calls to TESTPROC are inlined in both lines commented as Call 1 and Call 2.
E. Calls to TESTPROC might be inlined in the line commented as Call 2.

Question #4
Which statement is true about the DBMS_PARALLEL_EXECUTE package?
A. DBMS_PARALLEL_EXECUTE is a SYS-owned package and can be accessed only by a user with DBA privileges.
B. To execute chunks in parallel, users must have CREATE JOB system privilege.
C. No specific system privileges are required to create or run parallel execution tasks.
D. Only DBAs can create or run parallel execution tasks.
E. Users with CREATE TASK privilege can create or run parallel execution tasks.

Question #5
Which two statements are true regarding edition-based redefinition (EBR)?
A. There is no default edition defined in the database.
B. EBR does not let you upgrade the database components of an application while in use.
C. You never use EBR to copy the database objects and redefine the copied objects in isolation.
D. Editions are non-schema objects.
E. When you change an editioned object, all of its dependents remain valid.
F. Tables are not editionable objects.








Question #6
Which two blocks of code execute successfully?
A. 
DECLARE 
SUBTYPE new_one IS BINARY_INTERGER RANGE 0..9; 
my_val new_one;
BEGIN my_val :=0; 
END;

B. 
DECLARE 
SUBTYPE new_string IS VARCHAR2 (5) NOT NULL; 
my_str_new_string; 
BEGIN my_str := abc; 
END;

C. 
DECLARE 
SUBTYPE new_one IS NUMBER (2, 1);
 my_val new_one; 
BEGIN my_val :=12.5; 
END;

D. 
DECLARE 
SUBTYPE new_one IS INTEGER RANGE 1..10 NOT NULL; 
my_val new_one; 
BEGIN my_val :=2; 
END;

E. 
DECLARE 
SUBTYPE new_one IS NUMBER (1, 0); 
my_val new_one; 
BEGIN my_val := -1;

Question #7
Which statement is correct about DBMS_LOB.SETOPTIONS and DBMS_LOB.GETOPTIONS for SecureFiles?
A. DBMS_LOB.GETOPTIONS can only be used for BLOB data types.
B. DBMS_LOB.SETOPTIONS can perform operations on individual SecureFiles but not an entire column.
C. DBMS_LOB. SETOPTIONS can set option types COMPRESS, DUPLICATE, and ENCRYPT.
D. If a table was not created with compression specified in the store as securefile clause then DBMS_LOB.SETOPTIONS can be used to enable it later.







Question #8
You are designing and developing a complex database application built using many dynamic SQL statements. Which option could expose your code to SQL injection attacks?
A. Using bind variables instead of directly concatenating parameters into dynamic SQL statements
B. Using automated tools to generate code
C. Not validating parameters which are concatenated into dynamic SQL statements
D. Validating parameters before concatenating them into dynamic SQL statements
E. Having excess database privileges

Question #9
Examine this code executed as SYS:
 
Examine this code executed as SPIDER and the error message received upon execution:
 
What is the reason for this error?
A. The procedure needs to be granted the DYNAMIC_TABLE_ROLE role.
B. The EXECUTE IMMEDIATE clause is not supported with roles.
C. Privileges granted through roles are never in effect when running definer’s rights procedures.
D. The user SPIDER needs to be granted the CREATE TABLE privilege and the procedure needs to be granted the DYNAMIC_TABLE_ROLE.



Question #10
Which codes executes successfully?

A. 
CREATE PACKAGE pkg AS 
TYPE rec_typ IS RECORD (price NUMBER, inc_pct NUMBER); 
PROCEDURE calc_price (price_rec IN OUT rec_typ);
END pkg; 
/ 
CREATE PACAKGE BODY pkg AS 
PROCEDURE calc_price (price_rec IN OUT rec_typ) AS 
BEGIN 
price_rec.price := price_rec.price + (price_rec.price * price_rec.inc_pct)/100; 
END calc_price; 
END pkg; 
/
DECLARE 
1_rec pkg. rec_typ; 
BEGIN 
1_rec_price :=100; 
1_rec.inc_pct :=50;
EXECUTE IMMEDIATE 
BEGIN 
pkg. calc_price (:rec); 
END;
USING IN OUT 1_rec; 
END;

B. 
CREATE PACKAGE pkg AS 
TYPE rec_typ IS RECORD (price NUMBER, inc_pct NUMBER); 
END pkg; 
/ 
CREATE PROCEDURE calc_price (price_rec IN OUT pkg. rec_typ) AS 
BEGIN 
price_rec.price := price_rec.price + (price_rec.price * price_rec.inc_pct)/100; 
END 
/ 
DECLARE 
1_rec pkg.rec_typ; 
BEGIN 
EXECUTE IMMEDIATE 
BEGIN 
calc_price (:rec); 
END; 
USING IN OUT 1_rec (100, 50); 
END;

 C.
CREATE PACKAGE pkg AS 
TYPE rec_typ IS RECORD (price NUMBER, inc_pct NUMBER); 
END pkg; 
/ 
CREATE PROCEDURE calc_price (price_rec IN OUT pkg. rec_typ) AS 
BEGIN 
price_rec.price := price_rec.price + (price_rec.price * price_rec.inc_pct)/100; 
END ; 
/ 
DECLARE 
1_rec pkg.rec_typ; 
BEGIN 
1_rec_price :=100; 
1_rec.inc_pct :=50; 
EXECUTE IMMEDIATE 
BEGIN 
calc_price (1_rec); 
END;
END;

D.
DECLARE 
TYPE rec_typ IS RECORD (price NUMBER, inc_pct NUMBER); 
1_rec rec-typ;
PROCEDURE calc_price (price_rec IN OUT rec_typ) AS 
BEGIN 
price_rec.price := price-rec.price+ (price_rec.price * price_rec.inc_pct)/100; 
END;
BEGIN 
1_rec_price :=100; 
1_rec.inc_pct :=50; 
EXECUTE IMMEDIATE 
BEGIN
calc_price (:rec); 
END; 
USING IN OUT 1_rec;


Question #11
Examine this function header:

FUNCTION calc_new_sal (emp_id NUMBER) RETURN NUMBER;
You want to ensure that whenever this PL/SQL function is invoked with the same parameter value across active sessions, the result is not recomputed.
If a DML statement is modifying a table which this function depends upon, the function result must be recomputed at that point in time for all sessions calling this function.
Which two actions should you perform?

A. Ensure RESULT_CACHE_MAX_SIZE is greater than 0.
B. Enable the result cache by using DBMS_RESULT_CACHE.BYPASS (FALSE).
C. Add the deterministic clause to the function definition.
D. Add the RELIES_ON clause to the function definition.
E. Add the RESULT_CACHE clause to the function definition.










Question #12
Examine this block:
 
Which two will be correct after line 5?
A. va. LAST and va. LIMIT will return the same value.
B. va. LAST and va. COUNT will return the same value.
C. va. LIMIT and va. COUNT will return the same value.
D. va. LIMIT and va. NEXT (199) will return the same value.
E. va. LAST will return 200.
F. va. NEXT (199) will return NULL.






Question #13
 

Examine this code:
 

You want to display the contents of CREATE_LIST.
Which two lines need to be corrected in the PL/SQL block?
A. Line 2
B. Line 3
C. Line 5
D. Line 6
E. Line 7






Question #14
Examine the following SQL statement:
ALTER SESSION SET PLSQL_OPTIMIZE_LEVEL=3;
What is the result of executing this statements?
A. The PL/SQL optimize level for some existing PL/SQL units will be changed as an immediate result.
B. The PL/SQL optimize level for subsequently complied PL/SQL units will be set to 3 and inlining will be enabled.
C. The PL/SQL optimize level for subsequently compiled PL/SQL units will be set to 3 and inlining will be disabled.
D. This statement will fail because PLSQL_OPTIMIZE_LEVEL can only be set at the system level,

Question #15
Which two statements describe actions developers can take to make their application less vulnerable to security attacks?
A. Include the AUTHID DEFINER clause in stored program units.
B. Do not concatenate unchecked user input into dynamically constructed SQL statements.
C. Switch from using DBMS_SQL to EXECUTE IMMEDIATE.
D. Include the AUTHID CURRENT_USER clause in stored program units.
E. Increase the amount of code that is accessible to users by default.

Question #16
Examine this code:
 
What is the correct statement to get the value of attribute ACCOUNT_MGR after the procedure has been executed?
A. SELECT USERENV (‘ACCOUNT_MGR’) FROM dual;
B. SELECT SYS_CONTEXT (‘USERENV’, ‘ACCOUNT_MGR’) FROM dual;
C. SELECT SYS_CONTEXT (‘ORDER_CTX’, ‘ACCOUNT_MGR’) FROM dual;
D. SELECT SYS_CONTEXT (‘ACCOUNT_MGR’, ‘ORDER_CTX’) FROM dual;
E. SELECT USERENV (‘ORDER_CTX’) FROM dual;

Question #17
Which data dictionary view contains the list of procedures and functions defined within package specification that you can execute?
A. ALL_SOURCE
B. ALL_DEPENDENCIES
C. ALL_OBJECTS
D. ALL_PROCEDURES
E. ALL_PLSQL_OBJECT_SETTINGS

Question #18
Examine this code:
 
Examine this DML statement executed in the SCOTT schema:
UPDATE emp SET comm = 1000 WHERE deptno= 20;
What is the outcome after executing this statement?
A. COMM is set to 1000 for all records in the EMP table where DEPTNO = 30.
B. The statement executes successfully but no rows are updated.
C. COMM is set to 1000 for all records in the EMP table where DEPTNO=20.
D. The statement fails with error ORA-28115: policy with check option violation.

Question #19
Identify the two correct scenarios where a function can be optimized using the function result cache feature.
A. A function which inserts multiple records into a DEPARTMENTS table as part of one-time data setup for an HR application.
B. A function which accesses multiple tables and calculates the commission to be given to a sales representative based on the number of products sold by that representative.
C. A function which deletes all the records from an EMPLOYEES_AUDIT table based on their LOG_DATE.
D. A function which updates the SALARY of all the employees in an EMPLOYEES table by a fixed percentage based on their DESIGNATION.
E. A function which calculates the factorial of a given number without accessing any table.

Question #20
Select the correct statement regarding BEQUEATH CURRENT_USER.

A. If a view references a PL/SQL function then BEQUEATH CURRENT_USER allows the function to execute with DBA privileges, regardless of the invoking users privileges.
B. The BEQUEATH CURRENT_USER clause allows invoker’s rights functions referenced in a view to execute with the privileges of the invoking user.
C. Any view calling a PL/SQL function with BEQUEATH CURRENT_USER in effect will execute with the privileges of the function owner.
D. With the BEQUEATH CURRENT_USER clause, a definer’s rights function referenced in a view executes with the privileges of the view owner, not the function
















------------------------------------------------ANSWERS--------------------------------
---------------01----------------------
dendevelop
AE - is correct answer
   upvoted 10 times

Benjmaz
A is the only correct answer. D would have qualified if it had an "END" statement. Note that code block should be in between the BEGIN and END statements
   upvoted 1 times
 
Dana
I think that the correct answer is AE. "D" will return an "expression is of wrong type" error. Please re-check this!
   upvoted 4 times
 
dendevelop
Reason: You cannot assign a value to an explicit cursor, use it in an expression. stcur is explicit cursor in our example
   upvoted 4 times

---------------------------------02------------------------- 
JustinasSLT
 A,C are correct but you need to add Quotation marks, like: EXECUTE IMMEDIATE 'SELECT pdt_id, pdt_name FROM TABLE (:b)' BULK COLLECT INTO pkg.x USING y;
   upvoted 1 times
 
Nisha1
AC is working without Using Clause
   upvoted 1 times
 
CosminCof
 AC are the right answers; It wouldnt work if you dont use USING clause because there is a bind variable called ":b"
   upvoted 1 times

---------------------03----------------------
PLSQL_OPTIMIZE_LEVEL 
-Used to compile PL/SQL library units.
-Parameter Type INTEGER
-Range of Values 0 to 3
-Default value 2
-Basic NO

chaoyuim
C , E see here : https://docs.oracle.com/cd/B28359_01/appdev.111/b28370/inline_pragma.htm#LNPLS01362
   upvoted 7 times
 
-----------------------04------------------------
 DBMS_PARALLEL_EXECUTE package 
-allows a workload associated with a base table to be broken down into smaller chunks which can be run in parallel.
Correct Answer: B 
---------------------05---------------
Edition-Based Redefinition (EBR):
-Enables online application upgrade with uninterrupted availability of the application. 
-When the installation of an upgrade is complete, the pre-upgrade application and the post-upgrade application can be used at the same time. 
-allows hot rollover from the pre-upgrade version to the post-upgrade version, with zero downtime.
-EBR is available for use in all editions of Oracle Database without the need to license it.
 
CosminCof
DF are the correct answers: 
A- Default edition is ORABASE and sure can be modified; 
B- The purpose of an edition objects is to make downtime shorter while you want to upgrade the database while in use; 
C- You use EBR to redefine an object and isolate that object in his EDITION space; 
E- IF you changed an edition object all of its dependents become invalid
   upvoted 1 times

-------------------------06---------------------- 
Nisha1
AE 
A : successfully completed but some keyword should be in lower case DECLARE SUBTYPE new_one IS binary_integer range 0..9; my_val new_one; BEGIN my_val :=0; dbms_output.put_line(my_val); END; 
B : PLS-00218: a variable declared NOT NULL must have an initialization assignment 
C : ORA-06502: PL/SQL: numeric or value error: number precision too large 
D : PLS-00218: a variable declared NOT NULL must have an initialization assignment E : Correct
   upvoted 11 times
 
Josephgreenson
A : successfully completed but some keyword should be in lower case DECLARE SUBTYPE new_one IS binary_integer range 0..9; my_val new_one; BEGIN my_val :=0; dbms_output.put_line(my_val); END; 
B : PLS-00218: a variable declared NOT NULL must have an initialization assignment
C : ORA-06502: PL/SQL: numeric or value error: number precision too large
D : PLS-00218: a variable declared NOT NULL must have an initialization assignment E : Correct
   upvoted 1 times
  


peguynya
A,E are corrects but in A you just have to write integer not interger, and in E just add the END keyword
   upvoted 1 times
 
 
Swetank123
Correct Answer is AE not AD because subtype which is not null should be initialized in D option.

--------------------07----------------
jcamt
 Oracle recommends that you enable compression, deduplication, or encryption through the CREATE TABLE statement. If you enable these features through the ALTER TABLE statement, all SecureFiles LOB data in the table is read, modified, and written; this causes the database to lock the table during a potentially lengthy operation.
   upvoted 1 times
 
tassicek
 Is B because DUPLICATE is oposite of DEDUPLICATE ... https://docs.oracle.com/cd/E11882_01/appdev.112/e18294/adlob_smart.htm#ADLOB46109
   upvoted 3 times
 
Zayas
 I think B is the correct answer. GETOPTIONS() and SETOPTIONS() work on individual SecureFiles LOBs.
   upvoted 4 times
 
orakell
 The correct answer is C. The linked reference explicitly says the opposite of D.
 
orakell
On second thought I think B sounds better. The documentation says SETOPTIONS works on individual SecureFiles and doesn't say anything about working on entire columns. I don't think it's C anymore since the option is called DEDUPLICATE, not DUPLICATE.

--------08--------------------------
 
orakell
 The question asks which option COULD expose code. The answer is C.
   upvoted 10 times
 
CosminCof
 The answers are C and E. C->validation with DBMS_ASSERT E->SQL injection can be made by an user with a variety of privilleges
   upvoted 2 times
 
peguynya
The correct answer is C . A is not correct because the use of bind variables protect the Db form sql injection.
   upvoted 2 times
 
peguynya
The correct answer is C. A is not corrst because the using of bindings variables protect the Db from sql injection
   upvoted 2 times
 
Swetank123
bind variables protect against sql injection So, correct answer ic C.
   upvoted 4 times

--------------------09--------------------------

Josephgreenson
 C is correct.
   upvoted 1 times
 
CosminCof
B is the correct answer
   upvoted 1 times
 
Adela_bg
It's C
   upvoted 3 times



--------------------10--------------------------

Josephgreenson
 
A is correct, B gives error due to l_rec(100,50), PLS-00308: this construct is not allowed as the origin of an assignment
   upvoted 1 times
 
CosminCof
 A is the correct answer: 
B- You can’t use PL/SQL data types and record type into the USING clause; 
C- Would be correct if you use in the EXECUTE IMMEDIATE statement a bind variable for the function call and if you use clause USING IN OUT; in this situation function calc_price needs an IN OUT parameter, so using EXECUTE IMMEDIATE with a call to this function without a bind variable the compiler will give an error because it can’t return the result into the IN OUT variable. 
D- Here the USING clause of EXECUTE IMMEDIATE its using a RECORD type which is forbidden (as an explanation for the A answer, which is right, is good to use a record variable which is create under a package, because it becomes an SQL type and can be called from an SQL environment)
   upvoted 2 times
 
jcamt
 I verified in PL/SQL and ALL the sentences executes but all have error, the only who has less error is the B answer but the anonymous block has pragma error
   upvoted 1 times
 
peguynya
 B is correct, A is not correct because of this error (1_rec_price) it should be 1_rec.price
   upvoted 1 times
 
kahabe59
A is correct. l_rec(100, 50) is not a correct assignment
   upvoted 1 times
  
GuyFabrice
 No A is not a correct answer Look at this : DECLARE 1_rec pkg. rec_typ; BEGIN 1_rec_price :=100; 1_rec.inc_pct :=50; Warning : 1_rec_price don't exist. The correct code is : 1_rec.price := 100; So the correct answer is B
   upvoted 1 times
 
Josephgreenson
 1_rec_price must be a typo mistake in question.
   upvoted 1 times
 
protonik2020
Next time take time to check Your opinion. There is no posibility to use l_rec(100,50) as IN OUT param)
   upvoted 1 times


----------------11--------------
yurijk
 A and E

---------------------12------------------
Swetank123
Correct Answer will B and F because limit will be 200 count will be 100 and last will be 100 and next(199) will return null.
   upvoted 7 times
 
szefco
Confirm: B and F are correct answers: 
DECLARE TYPE va$ IS VARRAY(200) OF NUMBER;
 va va$ := va$(); 
BEGIN
 va.EXTEND(100); 
dbms_output.put_line('va.LIMIT = ' || va.LIMIT); 
dbms_output.put_line('va.LAST = ' || va.LAST); 
dbms_output.put_line('va.COUNT = ' || va.COUNT);
 dbms_output.put_line('va.NEXT(199) = ' || va.next(199)); 
end; 
Statement processed. va.LIMIT = 200 va.LAST = 100 va.COUNT = 100 va.NEXT(199) =
   upvoted 4 times

-------------13----------------------------
Benjmaz
 1 year, 6 months ago
Line 2, 6 and 7. Correct code should look like this 
DECLARE v_yrl yearly_list.list1 := yearly_list.init_list1(); 
location NUMBER := 1; 
BEGIN 
WHILE location IS NOT NULL LOOP DBMS_OUTPUT.PUT_LINE(v_yrl(location));
 location := v_yrl.NEXT(location);
 END LOOP; END;
   upvoted 1 times
 
sudhirdavim
A and E are correct answer.
   upvoted 1 times
 
CosminCof
AE correct answer
   upvoted 1 times
 

jcamt
 
verified 2 and 6, the error in 2 is PLS-00103: Encountered the symbol ")" and the 6 the error is DBMS_PUTPUT
   upvoted 1 times
 
DmitryPDN
 Line 2 is wrong because new variable requires type for itself. Line 7 is wrong since collection attribute next requires as input parameter the index of existing element from which we want to find next one like this array.next(curr_index).
   upvoted 2 times
 
yurijk
Line 2, line 7 -> A, E
   upvoted 3 times
 
orakell
 Line 3 is fine. Line 2 needs a lot of fixing, but I suspect this question has more issues in it.
   upvoted 3 times

---------------------------14----------------------
 
DmitryPDN
 B is the correct answer.
   upvoted 6 times
 
sudhirdavim
B is correct answer.
   upvoted 1 times
 
CosminCof
B is the correct answer
   upvoted 1 times
 
jcamt
the answer is B https://www.oracle.com/technical-resources/articles/database/sql-11g-plsql.html
   upvoted 1 times
 
certyk
Correct: B
   upvoted 1 times
 
Adela_bg
 I think B
   upvoted 1 times
 
orakell
Why disabled? Level 3 doesn't disable inlining. Level 3 makes inlining automatic more or less.
   upvoted 2 times

------------------------------------15---------------------
BD are correct answer.

------------------------16-------------------------
 
orakell
C, not B. Try it.
   upvoted 8 times
 
CosminCof
C is the correct answer
   upvoted 3 times
 
peguynya
the answer is C because SYS_CONTEXT(CONTEXT_NAME, PARAM1) returns the value of the parameter associated to the context namespace.
   upvoted 1 times

-----------------------17-----------------------
Correct Answer: D 

-------------18----------------------
sudhirdavim
 It is choice B for me as well when tested this script as it is.
   upvoted 2 times
 
Adela_bg
 D - For INSERT and UPDATE statements only, setting update_check to TRUE causes the server to check the policy against the value after INSERT or UPDATE. The check applies only to the security relevant columns that are included in the policy definition. In other words, the INSERT or UPDATE operation will fail only if the security relevant column that is defined in the policy is added or updated in the INSERT or UPDATE statement.
   upvoted 1 times
 
protonik2020
no, check first. Runing code show's B, becouse function return is added to a where clausule and there is no update at all
   upvoted 1 times
 
chaoyuim
https://oracle-base.com/articles/8i/virtual-private-databases
   upvoted 1 times
 
orakell
 2 years, 7 months ago
Choice B happens when I run this code.
   upvoted 3 times

----------------------------------19------------------------------------

CosminCof
 1 year, 7 months ago
It's B and E
   upvoted 2 times
 
jcamt
 1 year, 9 months ago
B and E because D has a data integrity problem when execute the update https://oracle-base.com/articles/11g/cross-session-plsql-function-result-cache-11gr1#:~:text=The%20cross%2Dsession%20PL%2FSQL,function%20with%20the%20same%20parameters.
   upvoted 3 times
 
olkaolka
 2 years ago
I think D,E Not B because there may be a different amount of sold products. Not C LOG_DATE changes constantly
   upvoted 1 times
 
protonik2020
 1 year, 11 months ago
why D ? Cache for update ?
   upvoted 1 times
 
orakell
 2 years, 8 months ago
B and E
   upvoted 3 times

-----------------------20---------------------
Correct Answer: B

Question #21
Which tablespace is used to store the data collected by PL/Scope?
A. UNDOTBS1
B. SYSAUX
C. SYSTEM
D. TEMP
E. USERS

Question #22
Which must be true in order to add RESULT_CACHE to a function header and have it compile successfully?
A. The IN parameters must not include BLOB, CLOB, collection or record data types.
B. The function must be created with invoker’s rights or in an anonymous block.
C. The function must be declared as a pipelined table function.
D. The function must have an OUT or an IN OUT parameter.

Question #23
Which two statements are true with respect to fine-grained access control?
A. It is implemented by end users.
B. It can be used to implement column masking.
C. It implements security rules through functions and associates these security rules with tables, views or synonyms.
D. Separate policies are required for queries versus INSERT/UPDATE/DELETE statements.
E. The DBMS_FGA package is used to set up fine-grained access control.

Question #24
 
Which two statements are correct about the collections before v3. DELETE is executed?
A. The values of v3(31) (2) and v3 (33) (2) are identical.
B. The value of v3 (31) (3) is 6.
C. The value of v3 (31) (1) and v3 (33) (3) are identical,
D. The value of v3 (31) (1) is "hello".
E. The values of v3 (32) (2) and v1 (2) are identical.

Question #25
Which two statements are true about the DBMS_ LOB package?
A. DBMS_LOB.COMPARE can compare parts of two LOBs.
B. DBMS_LOB.COMPARE returns the size difference of the compared LOBs.
C. DBMS_LOB.COMPARE is overloaded and can compare CLOBs with BLOBs.
D. If the destination LOB is a temporary LOB, the row must be locked before calling DBMS_LOB.CONVERTTOBLOB.
E. Before calling DBMS_LOB.CONVERTTOBLOB, both the source and destination LOB instances must exist.

Question #26
The STUDENTS table with column LAST_NAME of data type VARCHAR2 exists in your database schema.
Examine this PL/SQL block:
 
Which two actions must you perform for this PL/SQL block to execute successfully?
A. Replace the FOR loop with FOR name_rec IN names_varray.FIRST .. names_varray.LAST LOOP.
B. Replace the L_NAME_TYPE declaration with TYPE 1_name_type IS VARRAY (25) OF SYS_REFCURSOR;
C. Add name_rec name_cur%ROWTYPE; at the end of the DECLARE section.
D. Replace the NAMES_VARRAY declaration with names_varray 1_name_type := 1_name_type ();
E. Replace the NAMES_VARRAY declaration with names_varray 1_name_type := null;
F. Add names_varray.EXTEND after the FOR …LOOP statement.

Question #27
Which two blocks of code execute successfully?
DECLARE 
TYPE tab_type IS TABLE OF NUMBER;
my_tab tab_type; 
BEGIN 
my_tab (1) :=1; 
END;
DECLARE 
TYPE tab_type IS TABLE OF NUMBER; 
my_tab tab_type := tab_type(2); 
BEGIN 
my_tab(1) :=55;
END;
DECLARE 
TYPE tab_type IS TABLE OF NUMBER; 
my_tab tab_type; 
BEGIN 
my_tab. EXTEND (2); 
my_tab (1) := 55; 
END;
DECLARE 
TYPE tab_type IS TABLE OF NUMBER; 
my_tab tab_type; 
BEGIN 
my_tab := tab_type (); 
my_tab (1) := 55; 
END;
DECLARE 
TYPE tab_type IS TABLE OF NUMBER 
my_tab tab_type := tab_type (2, NULL, 50);
BEGIN 
my_tab.EXTEND (3, 2);

Question #28
Examine this code:
 
Users of this function may set different date formats in their sessions.
Which two modifications must be made to allow the use of your sessions date format when outputting the cached result of this function?
A. Change the RETURN type to DATE.
B. Change AUTHID to CURRENT_USER.
C. Use the TO_CHAR function around SYSDATE, that is, 1_date := TO_CHAR (SYSDATE).
D. Change the data type of 1_date to DATE.
E. Set NLS_DATE_FORMAT to ‘DD-MM-YY’ at the instance level.
F. Set the RESULT_CACHE_MODE parameter to FORCE.

Question #29
Which statement is true about internal and external LOBs?
A. An external LOB can be loaded into an internal LOB variable using the DBMS_LOB package.
B. A NOEXIST_DIRECTORY exception can be raised when using internal and external LOBs.
C. Internal and external LOBs can be written using DBMS_LOB.
D. After an exception transfers program control outside a PL/SQL block, all references to open external LOBs are lost.
E. When using DBMS_LOB.INSTR for internal and external LOBs, DBMS_LOB.OPEN should be called for each LOB.

Question #30
Which two statements about the PL/SQL hierarchical profiler are true?
A. Access it using the DBMS_PROFILER package.
B. Access it using the DBMS_HPROF package.
C. Profiler data is recorded in tables and published in HTML reports.
D. It is only accessible after a grant of the CREATE PROFILE privilege.
E. It helps you identify subprograms that are causing bottlenecks in application performance.

Question #31
Examine this Java method in class Employee, loaded into the Oracle database:
Public static int updateSalary (String name, float salary) {}
Which PL/SQL specification can be used to publish this method?
A. 
CREATE FUNCTION update_salary (p_nm VARCHAR2, p_sal NUMBER) 
RETURN PLS_INTEGER AS LANGUAGE JAVA LIBRARY 
"Employee" NAME "updateSalary" PARAMETERS (p_nm java.lang. String, p_sal float, RETURN int);
B. 
CREATE FUNCTION update_salary (p_nm VARCHAR2, p_sal NUMBER) 
RETURN PLS_INTEGER AS LANGUAGE JAVA NAME "Employee.updateSalary" PARAMETERS (p_nm java.lang.String, p_sal float, RETURN int);
C. 
CREATE FUNCTION update_salary (p_nm VARCHAR2, p_sal NUMBER)
RETURN PLS_INTEGER AS LANGUAGE JAVA NAME
 "Employee.updateSalary" PARAMETERS ("name" java.lang.String, "salary" float, RETURN int);

D. 
CREATE FUNCTION update_salary (p_nm VARCHAR2, p_sal NUMBER) 
RETURN PLS_INTEGER AS LANGUAGE JAVA NAME 
Employee.updateSalary (java.lang.String, float) return int;
E. 
CREATE FUNCTION update_salary (p_nm VARCHAR2, p_sal NUMBER) 
RETURN PLS_INTEGER AS LANGUAGE JAVA

Question #32

Examine this code executed in the ORA1 schema:
 
Examine this code executed by DBA_USER who has been granted the DBA role:
REVOKE INHERIT PRIVILEGES ON USER dba_user FROM PUBLIC;
Examine this query:
SELECT return_date (1) FROM dual;
What is the result of executing this query in the DBA_USER schema?
A. It will fail with a compile-time error.
B. It will execute successfully and return the date but the DBA role will not be granted to ORA1.
C. It will fail with a runtime error complaining of insufficient INHERIT PRIVILEGES.
D. It will execute successfully, return the date and the DBA role will be granted to ORA1.

Question #33
Which three commands can be used to set PL/SQL conditional compilation inquiry directive MODE?
A. ALTER SESSION SET PLSQL_CCFLAGS = ‘mode: FALSE’;
B. ALTER SESSION SET PLSQL_CCFLAGS= ‘mode: NULL’;
C. ALTER SESSION SET PLSQL_CCFLAGS= ‘mode: Level 1’;
D. ALTER SESSION SET PLSQL_CCFLAGS= ‘mode: Level1’;
E. ALTER SESSION SET PLSQL_CCFLAGS= ‘mode: 1’


Question #34
Examine this declaration section:
 
Which two executable sections will display the message Summary is null?
A. BEGIN 
1_rec := NULL; 
1_emp := emp_typ (1_rec); 
IF 1_emp (1).expr_summary IS EMPTY THEN 
DBMS_OUTPUT.PUT_LINE (Summary is null); 
END IF; END;
B. BEGIN 
1_rec.emp_id :=1; 
1_rec.expr_summary := NULL; 
1_emp :=emp_typ (1_rec); 
IF 1_emp(1).expr_summary IS NULL THEN 
DBMS_OUTPUT.PUT_LINE (Summary is null); 
END IF; END;
C. BEGIN 
1_rec.emp_id :=1; 
1_rec.expr_summary := EMPTY_CLOB (); 
1_emp := emp_typ (1_rec); 
IF 1_emp(1).expr_summary IS NULL THEN
DBMS_OUTPUT.PUT_LINE (Summary is null); 
END IF END;
D. BEGIN 
1_emp := emp_typ (); 
IF NOT 1_emp. EXISTS (1) THEN 
DBMS_OUTPUT.PUT_LINE (Summary is null);
END IF; END;
E. BEGIN 
1_emp. EXTEND; 
IF NOT 1_emp. EXISTS (1) THEN 
DBMS_OUTPUT.PUT_LINE (Summary is null); 
END IF; END;


Question #35
Examine this code:
 
Which two corrections must be applied for this anonymous block to execute successfully?
A. Change RETURN p_tab.LAST to RETURN p_tab.COUNT.
B. Declare the collection type inside the function.
C. Declare the collection type at the schema level instead of the package.
D. Define the function as stand-alone instead of in a package body.
E. Change the INDEX BY clause from VARCHAR2 to PLS_INTEGER.
F. Modify the function return type to return a scalar, VARCHAR2.








Question #36
Examine this code:
 
The anonymous block fails this error stack:
 
Which two changes, when separately applied, would prevent these errors from occurring?
A. Define v2 as employees%ROWTYPE.
B. Initialize v1 and v2 with appropriate constructor functions.
C. Define v2 as pkg. rec.
D. Nothing because using the function TABLE (V1) is prohibited.
E. Define v1 as employees%ROWTYPE.




----------------ANSWER------------------------

------------Question #21----------------
 
szefco
Correct answer is B: SYSAUX Source: https://docs.oracle.com/cd/B28359_01/appdev.111/b28424/adfns_plscope.htm#BABDGJAF PL/Scope stores the data that it collects in the SYSAUX tablespace
upvoted 4 times

------------Question #22----------------
Tinamoran
A is the right answer based on the link you provide -upvoted 9 times
chaoyuim
A: see here: ctrl F : Restrictions on Result-Cached Functions https://docs.oracle.com/cd/B28359_01/appdev.111/b28370/subprograms.htm#g3335204
upvoted 5 times
-----------------23---------------------
CosminCof
      BC is correct, upvoted 5 times
 
kahabe59
C and E are correct. You can't mask columns but lines by FGA
upvoted 1 times
 
kahabe59
I have to admit i was wrong. Column masking is possible so correct answers are B and C. DBMS_FGA is used for Fine Grained Auditing.
upvoted 4 times
 
orakell
BC, not CD. The linked reference says you CAN use separate policies, not that you're REQUIRED to use separate policies.
upvoted 4 times

-----------24--------------------
Tinamoran
CE v3(31)(2) = 1 v3(32)(2) = 5 v3(33)(1) = 1 v3(33)(3) = 1 v3(32)(2) = world v1(2) = world
upvoted 8 times
 
Benjmaz
is the only only answer. The statement says what is the value of the collection before v3. DELETE
upvoted 1 times

olkaolka
A,B,E Did it at server
upvoted 2 times

---------25------------ 
orakell
AE, not DE. D is false because it says temporary instead of persistent.
upvoted 11 times

certyk
A -> ref " This function compares two entire LOBs or parts of two LOBs."
E -> ref " Both the source and destination LOB instances must exist. " ref link -> https://docs.oracle.com/cd/B28359_01/appdev.111/b28419/d_lob.htm#BABDDFDH
upvoted 1 times
 
peguynya
A,E. D would have been true only if the lob was persistent.

-------------26-----------
orakell
DF, not EF. -upvoted 7 times
 
Benjmaz
D,F Working code below DECLARE CURSOR l_name_cur IS SELECT LAST_NAME FROM SIS.STUDENTS; TYPE l_name_type IS VARRAY(25) OF SIS.STUDENTS.last_name%type; names_array l_name_type := l_name_type(); v_index INTEGER := 0; BEGIN FOR name_rec IN l_name_cur LOOP names_array.EXTEND(); v_index := v_index + 1; names_array(v_index) := name_rec.last_name; DBMS_OUTPUT.PUT_LINE(names_array(v_index)); END LOOP; END; /
upvoted 2 times

---------27-------------------
Tinamoran
B and E are the right answer -upvoted 9 times
 
Wrath
B and E -upvoted 8 times
 
certyk
The ANs E missing ";" "end;". 
Anyhow i check it and seems that the correct answers are BC. 
The answer E could be fine if it was : 
"DECLARE TYPE tab_type IS TABLE OF NUMBER; 
my_tab tab_type := tab_type (2, NULL, 50); 
BEGIN my_tab.EXTEND (3, 2); 
END;" 
and not DECLARE
TYPE tab_type IS TABLE OF NUMBER 
my_tab tab_type := tab_type (2, NULL, 50); 
BEGIN my_tab.EXTEND (3, 2);
upvoted 1 times

-----------------28-------------------

sudhirdavim
A and D are correct answer. -upvoted 2 times
 
CosminCof
PRAGMA AUTHID is put on the question just to trick you (AUTHID works with SQL engine to verifies privilleges of an SQL user) Result Cache is used to trick you (if yu use sysdate the result of the function will never be cached). The answer is A and D (change the return type of the function and data type of local variable so the result of the function will be presented in the defaulte date format of the specific user)
upvoted 2 times
 
peguynya
A and D -upvoted 3 times

yurijk
didn't analyze this weird code, but A, C works as expected create or replace function invoice_date return date result_cache authid definer is l_date varchar2(50); begin l_date := to_char(SYSDATE); return l_date; end;
upvoted 4 times
 
orakell
C and D don't make sense together. C assigns a varchar2 to l_date and D changes the type of of l_date to DATE. Won't compile like that.

------------29------------
CosminCof
AD correct  -upvoted 1 times
 
jcamt
the only answer in the documentation is D https://docs.oracle.com/cd/E18283_01/appdev.112/e16760/d_lob.htm
upvoted 1 times
 
szefco
I think only A is correct. Question says "which STATEMENT" (singular, so there is only 1 correct answer)
upvoted 1 times
 
kahabe59
Only answer A is correct -upvoted 1 times
 
yurijk
A, D are correct -upvoted 2 times
 
orakell
AE, not DE. Only external LOBs need to be opened first, and the function to use is FILEOPEN, not OPEN.
upvoted 1 times
 
orakell
I meant AD, not DE, for the same reason. A and D are correct. -upvoted 1 times

--------------------30---------------------
kikkyy4
B and E -upvoted 2 times
 
CosminCof
This is good, B and E. -upvoted 4 times

---------------------31-------------------------
Tinamoran
 d is the right answer   -upvoted 6 times
 
DmitryPDN
Yes, Dis the correct answer since you should only point types of parameters, not their names in publication of java function.
   upvoted 3 times

----------------------32-------------------------
sudhirdavim 
Correct answer is C.  -upvoted 2 times

CosminCof
 B is the correct answer -upvoted 1 times
 
CosminCof
 My bad ... correct is C  -upvoted 2 times
 
Skiv
 Executing SELECT return_date(1) FROM dual; gives error: ORA-00904: "RETURN_DATE": invalid identifier, because query executed in DBA_USER schema and function return_date is in ORA1 schema. Then there should be option A?
   upvoted 1 times
 
CosminCof 
you forgot something, return_date function is granted to PUBLIC, it's not granted directly to DBA_USER ....
   upvoted 1 times
 
Marianusrex
 I think the B is the correct answer, as there is an exception handler within the granting routine, which catches the privilege error at execution.
   upvoted 3 times
 
DmitryPDN
 C is the correct answer according to this https://oracle-base.com/articles/12c/control-invoker-rights-privileges-for-plsql-code-12cr1
   upvoted 4 times
 
szefco
 B is correct answer, as per your source: "The presence of the exception handler means regular users can run the code without noticing a difference, even though the grant would fail."
   upvoted 1 times
 
szefco
 Apologies, my bad. @DmitryPDN is right. C is correct answer. in 12c Oracle added feature that throws an error in this situation
   upvoted 2 times

------------------------33-----------------------
Tinamoran
 A, B and E are the right answer   -upvoted 8 times
 
szefco
 Confirmed. A,B,E are correct answers   -upvoted 3 times
 
CosminCof 
ABE correct   -upvoted 2 times

-------------------------34----------------------
CosminCof
 BD correct    -upvoted 4 times
 
szefco
 B and E are correct answers. I verified it.   -upvoted 1 times
 
CosminCof
 B and D, not E because we see in this snippet using EXTEND function wich adds an NULL element in the collection.   -upvoted 1 times
 

--------------------------35----------------------
Orakell
EF, not DE.   -upvoted 6 times
 
CosminCof
EF correct   -upvoted 2 times
 
vlad4475
 Yea, EF correct. Checked here: 
CREATE package pkg as type tab_typ is table of varchar2(10) index by PLS_INTEGER; 
function tab_end (p_tab in tab_typ) return varchar2; end pkg; 
/ 
create package body pkg as function tab_end(p_tab in tab_typ)
return varchar2 is begin return p_tab.last; end; end pkg; 
/
declare l_stmt varchar2(100); l_list pkg.tab_typ;
 l_result varchar2(10); 
begin 
l_list(1) := 'Mon';
l_list(2) := 'Tue'; 
l_stmt := 'SELECT pkg.tab_end(:l_list) into :i_result from dual'; 
execute immediate l_stmt into l_result using l_list; dbms_output.put_line(l_result); 
end;
   

---------------------------36---------------------
orakell 
AC, not BE.   -upvoted 8 times
 
sudhirdavim
 AC is right answer.  -upvoted 1 times
 
GuyFabrice
 B and C   -upvoted 1 times
 
CosminCof
 B and C   -upvoted 2 times

